import React, { useCallback, useEffect, useState } from 'react';
import type { ReactNode } from 'react';

type ButtonProps = {
  onClick: () => void;
  children: ReactNode;
};
const Button = ({ onClick, children }: ButtonProps) => {
  return (
    <button onClick={onClick} className="button">
      {children}
    </button>
  );
};


const Child = ({ onChange }: { onChange: () => void }) => {
  useEffect(() => {
    console.info('Child re-renders !');
  });
  return <div onChange={onChange}>Some Child</div>;
};

const ChildMemo = React.memo(Child);

export default function App() {
  const [state, setState] = useState(1);

  const onChangeMemo = useCallback(() => {
    console.info('On change callback');
  }, []);

  return (
    <>
      Examples of a function non-memoized and memoized via useCallback or useMemo
      <br />
      <br />
      <Button onClick={() => setState(state + 1)}>Click to trigger re-render {state}</Button>
      <br />
      <br />
      <h3>Child component is not memoized here</h3>
      <p>So it will re-render when the button is clicked, even those it's onChange prop is memoized</p>
      <Child onChange={onChangeMemo} />
      <h3>This component is memoized</h3>
      <p>So it won't re-render when the button clicked</p>
      <ChildMemo onChange={onChangeMemo} />
    </>
  );
}
